/**
 * MarkdownReporter - GitHub-friendly markdown output
 */

import { writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';
import { Reporter } from './Reporter.js';
import { SuiteResult, TestStatus } from '../types.js';

export class MarkdownReporter implements Reporter {
  private outputDir: string;
  private results: SuiteResult[] = [];

  constructor(outputDir: string = './test-results') {
    this.outputDir = outputDir;
  }

  onSuiteStart(_suiteName: string): void {
    // No-op for Markdown reporter
  }

  onSuiteEnd(result: SuiteResult): void {
    this.results.push(result);
  }

  onRunComplete(
    results: SuiteResult[],
    summary: {
      totalSuites: number;
      totalTests: number;
      passed: number;
      failed: number;
      skipped: number;
    }
  ): void {
    const lines: string[] = [];

    // Header
    lines.push('# Browser Automation Test Results');
    lines.push('');
    lines.push(`**Date:** ${new Date().toISOString()}`);
    lines.push(`**Status:** ${summary.failed === 0 ? '✅ PASSED' : '❌ FAILED'}`);
    lines.push('');

    // Summary
    lines.push('## Summary');
    lines.push('');
    lines.push('| Metric | Count |');
    lines.push('|--------|-------|');
    lines.push(`| Total Suites | ${summary.totalSuites} |`);
    lines.push(`| Total Tests | ${summary.totalTests} |`);
    lines.push(`| ✅ Passed | ${summary.passed} |`);
    lines.push(`| ❌ Failed | ${summary.failed} |`);
    lines.push(`| ⏭️ Skipped | ${summary.skipped} |`);
    lines.push('');

    // Each suite
    for (const suite of results) {
      lines.push(`## Suite: ${suite.name}`);
      lines.push('');
      lines.push(`**Duration:** ${this.formatDuration(suite.duration)}`);
      lines.push('');

      // Test table
      lines.push('| Test | Status | Duration |');
      lines.push('|------|--------|----------|');

      for (const test of suite.tests) {
        const status = this.getStatusEmoji(test.status);
        const duration = this.formatDuration(test.duration);
        lines.push(`| ${test.name} | ${status} ${test.status} | ${duration} |`);
      }

      lines.push('');

      // Failures section
      const failures = suite.tests.filter((t) => t.status === TestStatus.FAILED);
      if (failures.length > 0) {
        lines.push('### Failures');
        lines.push('');

        for (const test of failures) {
          lines.push(`#### ${test.name}`);
          lines.push('');
          lines.push('```');
          lines.push(`Error: ${test.error?.message || 'Unknown error'}`);
          if (test.error?.stack) {
            lines.push('');
            lines.push(test.error.stack);
          }
          lines.push('```');
          lines.push('');
        }
      }
    }

    // Footer
    lines.push('---');
    lines.push('');
    lines.push('*Generated by Browser Automation Test Framework*');
    lines.push('');

    // Ensure output directory exists
    try {
      mkdirSync(this.outputDir, { recursive: true });
    } catch (error) {
      // Directory might already exist
    }

    // Write markdown file
    const outputPath = join(this.outputDir, `test-results-${Date.now()}.md`);
    writeFileSync(outputPath, lines.join('\n'), 'utf-8');

    console.log(`Markdown report written to: ${outputPath}`);
  }

  private getStatusEmoji(status: TestStatus): string {
    switch (status) {
      case TestStatus.PASSED:
        return '✅';
      case TestStatus.FAILED:
        return '❌';
      case TestStatus.SKIPPED:
        return '⏭️';
      default:
        return '❓';
    }
  }

  private formatDuration(ms: number): string {
    if (ms < 1000) {
      return `${ms}ms`;
    }
    return `${(ms / 1000).toFixed(2)}s`;
  }
}
